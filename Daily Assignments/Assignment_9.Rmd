---
title: "Assignment 9"
author: "Emily K. Power"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

1. Using a `for` loop and an `if` statement, write a function to calculate the number of zeroes in a numeric vector. Before entering the loop, set up a vector of integers with some zero values. Then, set up a counter variable `counter <- 0`. Inside the loop, add 1 to counter each time you have a zero in the vector. Finally, use `return(counter)` for the output.
```{r}
set.seed(12)  # set randomized values
v <- c(round(runif(50), digits=1))  # set up vector of integers with some zero values
v  # print vector

counter <- 0  # set up counter variable

for(i in 1:length(v)) {
  if(v[i]==0) {
    counter <- counter + 1} else{}
  print(counter)
}
v  # not working
```


2. Write a function that takes as input two integers representing the number of rows and columns in a matrix. The output is a matrix of these dimensions in which each element is the product of the row number x the column number.
```{r}
set.seed(143)  # set random numbers
rows <- sample(1:12, 1)  # select one random number
columns <- sample(1:12, 1)  # select one random number

########################################################################
# FUNCTION: func
# input: two integers representing the number of rows and columns in a matrix
# output: a matrix of these dimensions in which each element is the product of the row number x the column number
#-----------------------------------------------------------------------
func <- function(r=rows, c=columns) {  # set input as random integers defined previously
  m <- matrix(nrow=r, ncol=c)  # make matrix with r rows and c columns
  for (i in 1:nrow(m)){  # for each row in the matrix...
  for (j in 1:ncol(m)){   # for each column in the matrix...
    m[i,j] <- i * j  # ...make each value in the matrix a product of row * column
  }
}
  return(m)  # return matrix
}

output <- func()
output
```


3. Use a `for` loop to repeat your previous functions from Weekly Assignment 2 (which simulate a data frame and extract a p-value) 100 times. Store the results in a data frame that has 1 column indicating the replicate number and 1 column for the p-values (a total of 2 columns and 100 rows).
```{r}
########################################################################
# FUNCTION: new_function
# returns a data frame with 2 columns (named “Type” and “Value”) and 50 rows/observations
# input: mean and standard deviation
# outputs: "Type" and "Value"
#-----------------------------------------------------------------------
new_function <- function(means=c(10, 45), sds=c(1.5, 2), n=25){
  Type <- rep(c("Control", "Treatment"), each=n)  # create "Type" column with n "Control" and n "Treatment" variables
  Value <- c(rnorm(n, mean=means[1], sd=sds[1]), rnorm(n, mean=means[2], sd=sds[2]))  # generate random normally distributed values with set means and standard deviations
  df <- data.frame(Type, Value)  # generate data frame
  return(df)  # returns data frame
}
new_func <- new_function()
new_func

########################################################################
# FUNCTION: ANOVA_function
# returns the p-value of an ANOVA summary table
# input: a data frame
# outputs: p-value
#-----------------------------------------------------------------------
ANOVA_function <- function(df=NULL){
  test <- aov(Value ~ Type, data=df)  # same as before
  test_summary <- summary(test)  # makes test summary
  p_value <- test_summary[[1]][["Pr(>F)"]][1]  # pulls p value from test summary data frame
  return(p_value)  # returns p value
}

#########################################################################
output1 <- new_func[,2]  # create variable for new_function output excluding "Type" column
output2 <- ANOVA_function(new_func)  # create variable for ANOVA_function output

for(i in 1:100){  # repeat 100 times
  df <- data.frame(replicate_number = output1, p_values = output2)  # create data frame with two columns containing replicate numbers and p values
}
df  # print data frame
```

